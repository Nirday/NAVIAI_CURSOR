/**
 * Revision Engine
 * Revises blog posts and repurposed assets based on user feedback
 */

import OpenAI from 'openai'
import { supabaseAdmin } from '@/lib/supabase'
import { BlogPost, RepurposedAsset } from './types'
import { BusinessProfile } from '../../chat-core/src/types'
import { repurposeContent } from './repurposer'

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
})

/**
 * Revises blog post content and repurposed assets based on user feedback
 * Preserves core structure while applying requested changes
 * 
 * @param post - The blog post to revise
 * @param profile - The business profile for context
 * @param feedback - User's feedback/requested changes
 */
export async function reviseDraftAndAssets(
  post: BlogPost,
  profile: BusinessProfile,
  feedback: string
): Promise<void> {
  try {
    // Get content settings for CTA
    const { data: settingsData } = await supabaseAdmin
      .from('content_settings')
      .select('*')
      .eq('user_id', post.userId)
      .single()

    const primaryCta = settingsData?.primary_business_goal_cta || 'Contact us for more information'
    const targetPlatforms = settingsData?.target_platforms || ['linkedin', 'facebook', 'twitter', 'instagram']

    // Revise the main blog post content
    const revisedContent = await reviseBlogContent(post, profile, feedback, primaryCta)

    // Revise the SEO metadata if needed
    const revisedSeoMetadata = await reviseSeoMetadata(post, feedback)

    // Update the blog post with revised content
    await supabaseAdmin
      .from('blog_posts')
      .update({
        content_markdown: revisedContent,
        seo_metadata: revisedSeoMetadata
      })
      .eq('id', post.id)

    // Revise repurposed assets
    const revisedAssets = await reviseRepurposedAssets(post, profile, feedback, targetPlatforms)

    // Update repurposed assets
    await supabaseAdmin
      .from('blog_posts')
      .update({
        repurposed_assets: revisedAssets
      })
      .eq('id', post.id)

    console.log(`Successfully revised post ${post.id} based on feedback`)
  } catch (error) {
    console.error('Error revising content:', error)
    throw new Error(`Failed to revise content: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Revises the main blog post content based on feedback
 */
async function reviseBlogContent(
  post: BlogPost,
  profile: BusinessProfile,
  feedback: string,
  primaryCta: string
): Promise<string> {
  const prompt = `You are an Expert SEO Copywriter. Your task is to revise a blog post based on user feedback while preserving the core structure and SEO optimization.

**Original Blog Post:**
Title: ${post.title}
Content:
${post.contentMarkdown}

**Focus Keyword:** ${post.focusKeyword || 'N/A'}

**User Feedback:**
${feedback}

**Business Context:**
- Business: ${profile.businessName}
- Industry: ${profile.industry}
- Brand Voice: ${profile.brandVoice || 'professional'}
- Target Audience: ${profile.targetAudience || 'Local customers'}
- Primary CTA: "${primaryCta}"

**Requirements:**
1. Revise the blog post content based on the user's feedback
2. Preserve the core structure (headings, sections, flow)
3. Maintain strategic keyword placement for "${post.focusKeyword || 'the topic'}"
4. Ensure the CTA ("${primaryCta}") is naturally embedded at the end
5. Keep the same markdown formatting
6. Make the changes feel natural and integrated, not forced

**Output:**
Return the revised blog post content in markdown format. Return only the content, no JSON wrapper.`

  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: [
      {
        role: 'system',
        content: 'You are an Expert SEO Copywriter. You revise blog posts based on user feedback while maintaining SEO optimization and natural flow. Always return the revised content in markdown format.'
      },
      {
        role: 'user',
        content: prompt
      }
    ],
    temperature: 0.7,
    max_tokens: 4000
  })

  const content = response.choices[0]?.message?.content
  if (!content) {
    throw new Error('No revised content generated by AI')
  }

  return content.trim()
}

/**
 * Revises SEO metadata if the feedback affects it
 */
async function reviseSeoMetadata(
  post: BlogPost,
  feedback: string
): Promise<BlogPost['seoMetadata']> {
  // Only revise if feedback mentions title or description
  const lowerFeedback = feedback.toLowerCase()
  const needsRevision = lowerFeedback.includes('title') || 
                        lowerFeedback.includes('description') || 
                        lowerFeedback.includes('meta')

  if (!needsRevision) {
    return post.seoMetadata
  }

  const prompt = `You are an SEO Expert. Revise the SEO metadata based on user feedback.

**Original SEO Metadata:**
Meta Title: ${post.seoMetadata.metaTitle}
Meta Description: ${post.seoMetadata.metaDescription}
Focus Keyword: ${post.seoMetadata.focusKeyword || 'N/A'}

**User Feedback:**
${feedback}

**Blog Post Title:** ${post.title}

**Requirements:**
- Revise meta title (50-60 characters) if feedback mentions title
- Revise meta description (150-160 characters) if feedback mentions description
- Keep focus keyword: ${post.seoMetadata.focusKeyword || 'unchanged'}

**Output:**
Return a JSON object:
{
  "metaTitle": "[revised title]",
  "metaDescription": "[revised description]",
  "focusKeyword": "${post.seoMetadata.focusKeyword || null}"
}`

  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: [
      {
        role: 'system',
        content: 'You are an SEO Expert. You revise SEO metadata based on user feedback. Always return valid JSON.'
      },
      {
        role: 'user',
        content: prompt
      }
    ],
    temperature: 0.5,
    max_tokens: 500,
    response_format: { type: 'json_object' }
  })

  const content = response.choices[0]?.message?.content
  if (!content) {
    return post.seoMetadata
  }

  try {
    const parsed = JSON.parse(content)
    return {
      metaTitle: parsed.metaTitle || post.seoMetadata.metaTitle,
      metaDescription: parsed.metaDescription || post.seoMetadata.metaDescription,
      focusKeyword: parsed.focusKeyword || post.seoMetadata.focusKeyword
    }
  } catch {
    return post.seoMetadata
  }
}

/**
 * Revises repurposed assets based on feedback
 */
async function reviseRepurposedAssets(
  post: BlogPost,
  profile: BusinessProfile,
  feedback: string,
  targetPlatforms: Array<'linkedin' | 'facebook' | 'twitter' | 'instagram'>
): Promise<RepurposedAsset[]> {
  // Get revised content
  const { data: updatedPost } = await supabaseAdmin
    .from('blog_posts')
    .select('content_markdown')
    .eq('id', post.id)
    .single()

  const revisedContent = updatedPost?.content_markdown || post.contentMarkdown

  const prompt = `You are an Expert Social Media Marketing Expert. Your task is to revise social media assets based on user feedback.

**Original Blog Post:**
Title: ${post.title}
Content:
${revisedContent.substring(0, 3000)}${revisedContent.length > 3000 ? '...' : ''}

**Original Social Media Assets:**
${JSON.stringify(post.repurposedAssets || [], null, 2)}

**User Feedback:**
${feedback}

**Business Context:**
- Business: ${profile.businessName}
- Industry: ${profile.industry}
- Brand Voice: ${profile.brandVoice || 'professional'}

**Requirements:**
1. Revise all social media assets for platforms: ${targetPlatforms.join(', ')}
2. Apply the user's feedback to each asset
3. Maintain platform-specific best practices
4. Keep assets engaging and shareable

**Output:**
Return a JSON object with an "assets" key containing the revised assets array:
{
  "assets": [
    {
      "platform": "linkedin",
      "content": "[revised LinkedIn content]"
    },
    ...
  ]
}`

  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: [
      {
        role: 'system',
        content: 'You are an Expert Social Media Marketing Expert. You revise social media assets based on user feedback. Always return valid JSON.'
      },
      {
        role: 'user',
        content: prompt
      }
    ],
    temperature: 0.8,
    max_tokens: 2000,
    response_format: { type: 'json_object' }
  })

  const content = response.choices[0]?.message?.content
  if (!content) {
    // Fallback: regenerate assets using repurposer
    const tempPost = { ...post, contentMarkdown: revisedContent }
    await repurposeContent(tempPost, profile, targetPlatforms)
    const { data: updated } = await supabaseAdmin
      .from('blog_posts')
      .select('repurposed_assets')
      .eq('id', post.id)
      .single()
    return (updated?.repurposed_assets as RepurposedAsset[]) || []
  }

  try {
    const parsed = JSON.parse(content)
    const assets = parsed.assets || []
    return assets
      .filter((asset: any) => asset.platform && asset.content)
      .map((asset: any) => ({
        platform: asset.platform as RepurposedAsset['platform'],
        content: asset.content.trim(),
        imageUrl: asset.imageUrl || null
      }))
  } catch {
    // Fallback: regenerate assets
    const tempPost = { ...post, contentMarkdown: revisedContent }
    await repurposeContent(tempPost, profile, targetPlatforms)
    const { data: updated } = await supabaseAdmin
      .from('blog_posts')
      .select('repurposed_assets')
      .eq('id', post.id)
      .single()
    return (updated?.repurposed_assets as RepurposedAsset[]) || []
  }
}

