import { BusinessProfile } from '../../chat-core/src/types'
import { Website, WebsitePage, WebsiteSection } from './types'
import { upsertWebsiteDraft } from './data'
import { generateMatchingImage, generateGalleryImages } from './image_generator'
import { getTemplateById, getAllTemplates, getRecommendedTemplates } from './templates'

export interface GenerationOptions {
  pageNames: string[]
  templateId?: string // Optional: use a pre-defined template
  theme?: {
    colorPalette?: {
      primary?: string
      secondary?: string
      accent?: string
      background?: string
      surface?: string
      text?: string
    }
    font?: {
      heading?: string
      body?: string
    }
  }
}

export class WebsiteGenerationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'WebsiteGenerationError'
  }
}

export async function generateInitialWebsite(
  profile: BusinessProfile,
  options: GenerationOptions
): Promise<Website> {
  try {
    // V1.5: Get tracked phone number if available (replace real phone on website)
    let phoneNumberToUse = profile.contactInfo.phone
    try {
      const { getCallTrackingNumber } = await import('../../call-tracking/src/data')
      const trackedNumber = await getCallTrackingNumber(profile.userId)
      if (trackedNumber) {
        phoneNumberToUse = trackedNumber.twilioPhoneNumber
      }
    } catch (e) {
      // Fail silently - use real phone if tracking not available
      console.warn('Could not fetch tracked number, using real phone:', e)
    }
    
    // Create profile copy with tracked number
    const profileWithTrackedNumber: BusinessProfile = {
      ...profile,
      contactInfo: {
        ...profile.contactInfo,
        phone: phoneNumberToUse
      }
    }
    
    // Generate the website using AI
    const website = await generateWebsiteWithAI(profileWithTrackedNumber, options)
    
    // Validate the generated website structure
    validateGeneratedWebsite(website)
    
    // Auto-save first draft as 'draft'
    await upsertWebsiteDraft(profile.userId, website)
    
    return website
  } catch (error) {
    if (error instanceof WebsiteGenerationError) {
      throw error
    }
    
    // Retry once on any other error
    try {
      const website = await generateWebsiteWithAI(profile, options)
      validateGeneratedWebsite(website)
      await upsertWebsiteDraft(profile.userId, website)
      return website
    } catch (retryError) {
      throw new WebsiteGenerationError(
        `Failed to generate website after retry: ${retryError instanceof Error ? retryError.message : 'Unknown error'}`
      )
    }
  }
}

async function generateWebsiteWithAI(
  profile: BusinessProfile,
  options: GenerationOptions
): Promise<Website> {
  // If template is specified, use its theme
  let templateTheme = null
  if (options.templateId) {
    const template = getTemplateById(options.templateId)
    if (template) {
      templateTheme = template.theme
    }
  }
  
  // Merge template theme with custom theme (custom overrides template)
  const finalTheme = templateTheme 
    ? { ...templateTheme, ...options.theme }
    : options.theme
  
  const prompt = buildGenerationPrompt(profile, { ...options, theme: finalTheme })
  
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: 'You are an expert website generator. Generate complete, professional websites for local businesses. Always return valid JSON that matches the exact structure provided.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 4000
    })
  })

  if (!response.ok) {
    throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`)
  }

  const data = await response.json()
  const content = data.choices[0]?.message?.content

  if (!content) {
    throw new Error('No content generated by AI')
  }

  try {
    const website = JSON.parse(content) as Website
    
    // Add primaryCta from profile phone number
    if (profile.contactInfo.phone) {
      website.primaryCta = {
        text: 'Call Now',
        phoneNumber: profile.contactInfo.phone
      }
    }
    
    // Generate matching images for all sections that need them
    await generateImagesForWebsite(website, profile)
    
    return website
  } catch (parseError) {
    throw new Error(`Failed to parse AI response as JSON: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`)
  }
}

export interface PageGenerationOptions {
  schemaType?: 'FAQPage' | 'BlogPosting' | 'WebPage' | 'Review' | 'LocalBusiness';
  additionalContext?: string;
  keyword?: string;
}

export async function generatePageWithAI(
  profile: BusinessProfile, 
  title: string, 
  slug: string,
  options?: PageGenerationOptions
): Promise<WebsitePage> {
  const { schemaType = 'WebPage', additionalContext = '', keyword } = options || {}
  
  const schemaInstructions = getSchemaInstructions(schemaType, profile, keyword)
  
  const prompt = `Generate a single website page as JSON matching the WebsitePage interface. Return ONLY the JSON.
Title: ${title}
Slug: ${slug}
Business: ${profile.businessName} in ${profile.location.city}, ${profile.location.state} (${profile.industry})
Brand voice: ${profile.brandVoice}
${additionalContext ? `Additional Context: ${additionalContext}\n` : ''}${keyword ? `Target Keyword: ${keyword}\n` : ''}
Requirements:
- Include a hero section with a compelling headline and brief subheadline in the specified brand voice
- Include a text section with 1-2 short paragraphs appropriate for a local business
- Do not include analytics or styling; focus on content fields only
- Ensure fields: id, slug, title, metaTitle, metaDescription (<160 chars), structuredData, sections[]
- CRITICAL: The structuredData field MUST include valid Schema.org JSON-LD markup of type "${schemaType}"
${schemaInstructions}
`

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: 'Return valid JSON only.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.6,
        max_tokens: 1200
      })
    })

    if (!response.ok) throw new Error(`OpenAI API error: ${response.status}`)
    const data = await response.json()
    const content = data.choices[0]?.message?.content
    if (!content) throw new Error('AI returned no content')
    const page = JSON.parse(content)
    // Ensure required fields
    if (!page.id) page.id = crypto.randomUUID()
    page.slug = slug
    page.title = title
    if (!page.metaTitle) page.metaTitle = title
    if (!page.metaDescription) page.metaDescription = `${title} – ${profile.businessName}`.slice(0, 155)
    if (!Array.isArray(page.sections)) {
      page.sections = [
        { id: crypto.randomUUID(), type: 'hero', headline: title },
        { id: crypto.randomUUID(), type: 'text', content: `Welcome to ${profile.businessName}.` }
      ]
    }
    return page as WebsitePage
  } catch {
    // Safe fallback (non-AI)
    return {
      id: crypto.randomUUID(),
      slug,
      title,
      metaTitle: title,
      metaDescription: `${title} – ${profile.businessName}`.slice(0, 155),
      structuredData: {
        '@context': 'https://schema.org',
        '@type': 'LocalBusiness',
        name: profile.businessName
      },
      sections: [
        { id: crypto.randomUUID(), type: 'hero', headline: title },
        { id: crypto.randomUUID(), type: 'text', content: `Welcome to ${profile.businessName}.` }
      ]
    }
  }
}

function buildGenerationPrompt(profile: BusinessProfile, options: GenerationOptions): string {
  const { pageNames, theme } = options
  
  return `Generate a complete website for this business. Return ONLY a valid JSON object matching the Website interface structure.

BUSINESS PROFILE:
- Name: ${profile.businessName}
- Industry: ${profile.industry}
- Location: ${profile.location.city}, ${profile.location.state}
- Address: ${profile.location.address}
- Phone: ${profile.contactInfo.phone}
- Email: ${profile.contactInfo.email}
- Website: ${profile.contactInfo.website || 'Not provided'}
- Services: ${JSON.stringify(profile.services)}
- Hours: ${JSON.stringify(profile.hours)}
- Brand Voice: ${profile.brandVoice}
- Target Audience: ${profile.targetAudience}
- Custom Attributes: ${JSON.stringify(profile.customAttributes)}

REQUESTED PAGES: ${pageNames.join(', ')}

THEME PREFERENCES:
${theme ? JSON.stringify(theme, null, 2) : 'Use professional defaults'}

REQUIREMENTS:
1. Generate exactly the pages requested: ${pageNames.join(', ')}
2. Write ALL content in the ${profile.brandVoice} brand voice
3. Create professional, high-quality content appropriate for a local business
4. Include compelling meta descriptions under 160 characters
5. Generate appropriate Schema.org structured data for each page type
6. Use the business information to create relevant, personalized content
7. If information is missing, create professional placeholder content
8. Ensure all content is suitable for the target audience: ${profile.targetAudience}
9. DO NOT include image URLs (backgroundImageUrl, image urls in galleries) - leave them null/empty. Images will be generated separately to match content exactly.
10. For image_gallery sections, include detailed descriptions of what each image should show in a "imageDescriptions" array field

JSON STRUCTURE TO RETURN:
{
  "id": "generate-uuid-here",
  "userId": "${profile.userId}",
  "name": "${profile.businessName} Website",
  "domain": null,
  "theme": {
    "colorPalette": {
      "primary": "#3B82F6",
      "secondary": "#1E40AF",
      "accent": "#F59E0B",
      "background": "#FFFFFF",
      "surface": "#F8FAFC",
      "text": "#1F2937"
    },
    "font": {
      "heading": "Inter",
      "body": "Inter"
    }
  },
  "pages": [
    {
      "id": "page-uuid-here",
      "slug": "page-slug-here",
      "title": "Page Title",
      "metaTitle": "SEO Title (under 60 chars)",
      "metaDescription": "Compelling description (under 160 chars)",
      "structuredData": {
        "@context": "https://schema.org",
        "@type": "LocalBusiness",
        // ... appropriate schema for page type
      },
      "sections": [
        {
          "id": "section-uuid-here",
          "type": "hero|feature|text|image_gallery|contact_form|embed|video",
          // ... section-specific properties
        }
      ]
    }
  ],
  "primaryCta": null,
  "createdAt": "${new Date().toISOString()}",
  "updatedAt": "${new Date().toISOString()}"
}

IMPORTANT: Return ONLY the JSON object. No additional text or formatting.`
}

function getSchemaInstructions(schemaType: string, profile: BusinessProfile, keyword?: string): string {
  switch (schemaType) {
    case 'FAQPage':
      return `Schema.org Requirements for FAQPage:
- Use @type: "FAQPage"
- Include a mainEntity array with Question/Answer pairs
- Each Question must have @type: "Question" with text property
- Each Answer must have @type: "Answer" with text property
- Generate 5-8 relevant questions based on the business type (${profile.industry})`
    case 'BlogPosting':
      return `Schema.org Requirements for BlogPosting:
- Use @type: "BlogPosting"
- Include headline, datePublished, author (Organization with name: "${profile.businessName}")
- Include articleBody with the main content
${keyword ? `- Optimize content for keyword: "${keyword}"` : ''}`
    case 'Review':
      return `Schema.org Requirements for Review:
- Use @type: "Review"
- Include reviewRating (@type: "Rating", ratingValue)
- Include itemReviewed (LocalBusiness with name: "${profile.businessName}")
- Include author and reviewBody`
    case 'LocalBusiness':
      return `Schema.org Requirements for LocalBusiness:
- Use @type: "LocalBusiness"
- Include name, address, telephone, email
- Include openingHours, priceRange if applicable`
    default:
      return `Schema.org Requirements:
- Use appropriate @type for the page content
- Include basic LocalBusiness information`
  }
}

/**
 * Generates matching images for all sections that need them
 * This ensures images accurately match the content
 */
async function generateImagesForWebsite(website: Website, profile: BusinessProfile): Promise<void> {
  for (const page of website.pages) {
    for (const section of page.sections) {
      try {
        if (section.type === 'hero' && 'headline' in section) {
          // Generate hero background image
          const heroContent = `${section.headline}${section.subheadline ? ` - ${section.subheadline}` : ''}`
          if (heroContent && !section.backgroundImageUrl) {
            const imageUrl = await generateMatchingImage({
              businessName: profile.businessName,
              industry: profile.industry,
              location: profile.location,
              content: heroContent,
              sectionType: 'hero',
              pageTitle: page.title,
              brandVoice: profile.brandVoice
            })
            section.backgroundImageUrl = imageUrl
          }
        } else if (section.type === 'image_gallery' && 'images' in section) {
          // Check if we have image descriptions to generate from
          const anySection = section as any
          if (anySection.imageDescriptions && Array.isArray(anySection.imageDescriptions)) {
            const galleryImages = await generateGalleryImages(
              profile,
              anySection.imageDescriptions,
              page.title
            )
            section.images = galleryImages
            // Remove the temporary imageDescriptions field
            delete anySection.imageDescriptions
          }
        }
      } catch (error: any) {
        console.error(`[Image Generation] Failed to generate image for section ${section.id}:`, error)
        // Continue with other sections even if one fails
      }
    }
  }
}

function validateGeneratedWebsite(website: Website): void {
  if (!website.id || !website.userId || !website.name) {
    throw new WebsiteGenerationError('Generated website missing required fields')
  }
  
  if (!website.pages || website.pages.length === 0) {
    throw new WebsiteGenerationError('Generated website has no pages')
  }
  
  for (const page of website.pages) {
    if (!page.id || !page.slug || !page.title || !page.sections) {
      throw new WebsiteGenerationError(`Page ${page.title || 'unknown'} missing required fields`)
    }
    
    for (const section of page.sections) {
      if (!section.id || !section.type) {
        throw new WebsiteGenerationError(`Section in page ${page.title} missing required fields`)
      }
    }
  }
}
